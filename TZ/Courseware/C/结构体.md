***
[TOC]
***

# `1. 概述`
> 由一系列具有相同类型或不同类型的数据构成的数据集合，叫做结构。

> 在C语言中，结构体(struct)指的是一种数据结构，是C语言中聚合数据类型(aggregate data type)的一类。结构体可以被声明为变量、指针或数组等，用以实现较复杂的数据结构。结构体同时也是一些元素的集合，这些元素称为结构体的成员(member)，且这些成员可以为不同的类型，成员一般用名字访问。 

# `2. 声明与定义`
`无 typedef`
```
结构体关键字 <辅助类型名> { <成员> } <变量名0, ..., 变量名n> ;
形如:
struct _CLASS_NAME
{
};

struct
{
    int i;
    char ch;
}VARIABLE_NAME;

struct _CLASS_NAME
{
    int i;
    char ch;
};

struct _CLASS_NAME
{
    int i;
    char ch;
}VARIABLE_NAME;
 
struct
{
    int i;
    char ch;
}VARIABLE_NAME0, VARIABLE_NAME1, VARIABLE_NAME2, *PVARIABLE_NAME3;

1. struct为结构体类型关键字
2. _CLASS_NAME为结构体的辅助类型名，
3. <成员> 为结构体成员列表，其必须列出其所有成员；
4. <变量名0, ..., 变量名n> 是变量列表
5. 分号, 分号, 分号;
```

`typedef`

typedef的作用是: 给结构体类型取个别名,简化类型的写法;如:

```
typedef 结构体关键字 <辅助类型名> { <成员> } <类型别名0, ..., 类型别名n> ;

struct _NODE
{
    int iData;
    struct _CLASS_NAME * pNext;  
}node;
// node 是变量

typedef struct _NODE
{
    int iData;
    struct _CLASS_NAME * pNext;  
}NODE, *PNODE;
// NODE & PNODE 是结构体类型

typedef struct _NODE NODE, *PNODE;
// NODE & PNODE 是结构体类型
struct _NODE
{
    int iData;
    PNODE pNext;  
};
```

# `3. 结构体的大小与内存对齐`
> 结构体的大小不是结构体元素单纯相加就行的，因为我们主流的计算机使用的都是32bit字长的CPU，对这类型的CPU取4个字节的数要比取一个字节要高效，也更方便。所以在结构体中每个成员的首地址都是4的整数倍的话，取数据元素时就会相对更高效，这就是内存对齐的由来。每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。程序员可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。

内存对齐规则：
> 1. 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。 
> 2. 结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。 
> 3. 结合1、2可推断：当#pragma pack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。


# `4.结构体注意`

1. 这是C语言, 这是C语言, 这是C语言;
2. 结构体类型名是 struct + 辅助类型名;
3. 结构体的各部分可以有限度的没有;
4. 成员不能在内部初始化;
5. 内部不能有函数;
6. typedef的时候,是给结构体类型名取别名;
7. 结构体的内存对齐在把数据保存到硬盘中,很重要;
   因为要恢复该结构体时,大小要对应;

# `5.访问成员`

1. 如果结构体变量非是指针变量,那么用.去访问;
2. 如果结构体变量是指针变量,那么用\->去访问;