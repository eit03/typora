***
`CriticalSection:` https://msdn.microsoft.com/en-us/library/windows/desktop/ms682530(v=vs.85).aspx

`Mutex:` https://msdn.microsoft.com/en-us/library/windows/desktop/ms684266(v=vs.85).aspx

`Semaphore:` https://msdn.microsoft.com/en-us/library/windows/desktop/ms685129(v=vs.85).aspx

`Event:` https://msdn.microsoft.com/en-us/library/windows/desktop/ms682655(v=vs.85).aspx

`SRWLock:` https://msdn.microsoft.com/en-us/library/windows/desktop/aa904937(v=vs.85).aspx

***
[TOC]
***


# `0. 引子`

```
#include <windows.h>
#include <process.h>
#include <stdio.h>


int g_i{};			// 全局计数变量

unsigned(__stdcall ThreadProc)(void*);

int main()
{
	HANDLE hThread[2]{};
	hThread[0] = (HANDLE)_beginthreadex(0, 0, &ThreadProc, 0, 0, 0);
	hThread[1] = (HANDLE)_beginthreadex(0, 0, &ThreadProc, 0, 0, 0);
	WaitForMultipleObjects(2, hThread, 1, INFINITE);

	printf("%d\n", g_i);

	system("pause");

	return 0;
}

unsigned __stdcall ThreadProc(void*)
{
	int i = 1000000;
	while (i--) 
		g_i++;

	return 0;
}
```

# `1. 原子操作`

| Function                   | Description                                     |
| -------------------------- | ----------------------------------------------- |
| InterlockedIncrement       | 给一个整形变量自增1.                            |
| InterlockedExchangeAdd     | 为一个整形变量以原子 方式加上一个数.            |
| InterlockedExchange        | 将一个32位数以原子方式赋值给另一个数.           |
| InterlockedExchange64      | 将一个64位数以原子方式赋值给另一个数.           |
| InterlockedCompareExchange | 如果两个数相等,就将另外一个数赋值,不相等无效果. |

```
#include <windows.h>
#include <process.h>
#include <stdio.h>


int g_i{};			// 全局计数变量

unsigned(__stdcall ThreadProc)(void*);

int main()
{
	HANDLE hThread[2]{};
	hThread[0] = (HANDLE)_beginthreadex(0, 0, &ThreadProc, 0, 0, 0);
	hThread[1] = (HANDLE)_beginthreadex(0, 0, &ThreadProc, 0, 0, 0);
	WaitForMultipleObjects(2, hThread, 1, INFINITE);

	printf("%d\n", g_i);

	system("pause");

	return 0;
}

unsigned __stdcall ThreadProc(void*)
{
	int i = 1000000;
	while (i--)
	{
		InterlockedIncrement(reinterpret_cast<LONG*>(&g_i));
		//InterlockedExchangeAdd(reinterpret_cast<LONG*>(&g_i), 2);
		//InterlockedExchange();
		//InterlockedExchange64();
		//InterlockedCompareExchange(reinterpret_cast<LONG*>(&g_i), ++g_i, 0);
	}

	return 0;
}
```

```
#include <windows.h>
#include <process.h>
#include <stdio.h>


DWORD g_dwLocked{};	//是否上锁 
int g_i{};		   //全局计数变量

unsigned(__stdcall ThreadProc)(void*);

int main()
{
	HANDLE hThread[2]{};
	hThread[0] = (HANDLE)_beginthreadex(0, 0, &ThreadProc, 0, 0, 0);
	hThread[1] = (HANDLE)_beginthreadex(0, 0, &ThreadProc, 0, 0, 0);
	WaitForMultipleObjects(2, hThread, 1, INFINITE);

	printf("%d\n", g_i);

	system("pause");

	return 0;
}

unsigned __stdcall ThreadProc(void*)
{
	//g_dwLocked = 1;
	int i = 1000000;
	while (i--)
	{
		//InterlockedIncrement(reinterpret_cast<LONG*>(&g_i));
		//InterlockedExchangeAdd(reinterpret_cast<LONG*>(&g_i), 2);
		//InterlockedExchange();
		//InterlockedExchange64();
		while (InterlockedCompareExchange(reinterpret_cast<LONG*>(&g_dwLocked), 1, 0));   //compare and swap
		g_i++;
		g_dwLocked = 0;
	}

	return 0;
}
```

# `2. SRWLock`

| Function                                        | Descriptions     |
| :---------------------------------------------- | ------------------ |
| InitializeSRWLock/SleepConditionVariableSRW     | 初始化读写锁/释放读写锁|
| AcquireSRWLockExclusive/ReleaseSRWLockExclusive | 请求读锁/释放读锁     |
| AcquireSRWLockShared/ReleaseSRWLockShared       | 请求写锁/释放写锁     |

适用于读多写少的时候.只存在==读==or==一个写==or==Nothing==三种状态.

# `3. CriticalSection`

| Function                                        | Describe |
| ----------------------------------------------- | -------- |
| InitializeCriticalSection/DeleteCriticalSection |          |
| EnterCriticalSection/LeaveCriticalSection       |          |

==临界区只是本进程可见的.==

==线程意外死亡,临界出可能得不到释放.==

==临界区是一个进程内的线程间的轻量的互斥对象.拥有者线程代码一直是有信号的,其它线程没有信号.拥有者线程代码每进一次临界区就会累加锁,退出临界区就会累减锁.==



CriticalSection是最快的。
其他内核锁（事件、互斥体），每进一次内核，都需要上千个CPU周期。
使用临界区域的第一个忠告就是不要长时间锁住一份资源。这里的长时间是相对的，视不同程序而定。对一些控制软件来说，可能是数毫秒，但是对另外一些程序来说，可以长达数分钟。
但进入临界区后必须尽快地离开，释放资源。如果不释放的话，会如何？答案是不会怎样。如果是主线程（GUI线程）要进入一个没有被释放的临界区，呵呵，程序就会挂了！
临界区域的一个缺点就是：Critical Section不是一个核心对象，无法获知进入临界区的线程是生是死，如果进入临界区的线程挂了，没有释放临界资源，系统无法获知，而且没有办法释放该临界资源。这个缺点在互斥器(Mutex)中得到了弥补。



```
#include <windows.h>
#include <process.h>
#include <stdio.h>


CRITICAL_SECTION g_cs{};
int g_i{};			//全局计数变量

unsigned(__stdcall ThreadProc)(void*);

int main()
{
	InitializeCriticalSection(&g_cs);

	HANDLE hThread[2]{};
	hThread[0] = (HANDLE)_beginthreadex(0, 0, &ThreadProc, 0, 0, 0);
	hThread[1] = (HANDLE)_beginthreadex(0, 0, &ThreadProc, 0, 0, 0);
	WaitForMultipleObjects(2, hThread, 1, INFINITE);

	DeleteCriticalSection(&g_cs);

	printf("%d\n", g_i);

	system("pause");

	return 0;
}

unsigned __stdcall ThreadProc(void*)
{
	//g_dwLocked = 1;
	int i = 1000000;
	while (i--)
	{
		EnterCriticalSection(&g_cs);
		g_i++;
		LeaveCriticalSection(&g_cs);
	}

	return 0;
}
```

# `4. Mutex`

| Function                          | Description |
| --------------------------------- | ----------- |
| CreateMutex/OpenMutex/CloseHandle |             |
| WaitForSingleObject/ReleaseMutex  |             |

==互斥体是内核对象.==

==互斥体是内核对象.拥有者线程代码一直是有信号的,其它线程没有信号.拥有者线程代码每进一次互斥区就会累加锁,退出互斥区就会累减锁.它与临界区十分相似.==



互斥体的功能和临界区域很相似。
区别是：Mutex所花费的时间比Critical Section多的多，但是Mutex是核心对象(Event、Semaphore也是)，可以跨进程使用，而且等待一个被锁住的Mutex可以设定 TIMEOUT，不会像Critical Section那样无法得知临界区域的情况，而一直死等。



```
#include <windows.h>
#include <process.h>
#include <stdio.h>


HANDLE g_hMutex{};
int g_i{};			//全局计数变量

unsigned(__stdcall ThreadProc)(void*);

int main()
{
	g_hMutex = CreateMutex(0, 0, 0);

	HANDLE hThread[2]{};
	hThread[0] = (HANDLE)_beginthreadex(0, 0, &ThreadProc, 0, 0, 0);
	hThread[1] = (HANDLE)_beginthreadex(0, 0, &ThreadProc, 0, 0, 0);
	WaitForMultipleObjects(2, hThread, 1, INFINITE);

	CloseHandle(g_hMutex);

	printf("%d\n", g_i);

	system("pause");

	return 0;
}

unsigned __stdcall ThreadProc(void*)
{
	//g_dwLocked = 1;
	int i = 100000;
	while (i--)
	{
		WaitForSingleObject(g_hMutex, INFINITE);
		g_i++;
		ReleaseMutex(g_hMutex);
	}

	return 0;
}
```



# `5. Semaphore`

| Function                                  | Description |
| ----------------------------------------- | ----------- |
| CreateSemaphore/OpenSemaphore/CloseHandle |             |
| WaitForSingleObject/ReleaseSemaphore      |             |

信号量（Semaphore）内核对象对线程的同步方式与前面几种方法不同，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。



```
#include <windows.h>
#include <process.h>
#include <stdio.h>


HANDLE g_hSemaphore{};
int g_i{};			//全局计数变量

unsigned(__stdcall ThreadProc)(void*);

int main()
{
	g_hSemaphore = CreateSemaphore(0, 1, 1, 0);

	HANDLE hThread[2]{};
	hThread[0] = (HANDLE)_beginthreadex(0, 0, &ThreadProc, 0, 0, 0);
	hThread[1] = (HANDLE)_beginthreadex(0, 0, &ThreadProc, 0, 0, 0);
	WaitForMultipleObjects(2, hThread, 1, INFINITE);

	CloseHandle(g_hSemaphore);

	printf("%d\n", g_i);

	system("pause");

	return 0;
}

unsigned __stdcall ThreadProc(void*)
{
	//g_dwLocked = 1;
	int i = 100000;
	while (i--)
	{
		WaitForSingleObject(g_hSemaphore, INFINITE);
		g_i++;
		ReleaseSemaphore(g_hSemaphore, 1, 0);
	}

	return 0;
}
```



# `7. Event`

| Function                                   | Description |
| ------------------------------------------ | ----------- |
| CreateEvent/OpenEvent/CloseHandle          |             |
| WaitForSingleObject/WaitForMultipleObjects |             |
| SetEvent/ResetEvent/PulseEvent             |             |

用事件（Event）来同步线程是最具弹性的了。

一个事件有两种状态：激发状态和未激发状态。也称有信号状态和无信号状态。

事件又分两种类型：手动重置事件和自动重置事件。

手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。

自动重置事件被设置为激发状态后，会唤醒“一个”等待中的线程，然后自动恢复为未激发状态。所以用自动重置事件来同步两个线程比较理想。

```
#include <windows.h>
#include <process.h>
#include <stdio.h>


HANDLE g_hEvent{};
int g_i{};			//全局计数变量

unsigned(__stdcall ThreadProc)(void*);

int main()
{
	g_hEvent = CreateEvent(0, 0, TRUE, 0);

	HANDLE hThread[2]{};
	hThread[0] = (HANDLE)_beginthreadex(0, 0, &ThreadProc, 0, 0, 0);
	hThread[1] = (HANDLE)_beginthreadex(0, 0, &ThreadProc, 0, 0, 0);
	WaitForMultipleObjects(2, hThread, 1, INFINITE);

	CloseHandle(g_hEvent);

	printf("%d\n", g_i);

	system("pause");

	return 0;
}

unsigned __stdcall ThreadProc(void*)
{
	//g_dwLocked = 1;
	int i = 100000;
	while (i--)
	{
		WaitForSingleObject(g_hEvent, INFINITE);
		g_i++;
		SetEvent(g_hEvent);
	}

	return 0;
}
```

# `8. 作业`

作业: 编写程序完成如下功能：(用到线程同步)
花式解决昨天的问题; (能写多少种就多少种)