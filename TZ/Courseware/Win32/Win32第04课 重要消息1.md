***
[TOC]
***

# `1. WM_CREATE`
## `1.1 何时发送`
当应用程序通过调用CreateWindowEx()或CreateWindow()请求创建窗口时发送这个消息;可以这么理解在CreateWindow()的代码中有一条语句是SendMessage(句柄, WM_CREATE, wParam, lParam);想想,发送这个消息的时候窗口是创建好了,因为有窗口句柄,但是我们的或CreateWindow()没有执行完成,它的句柄接收者还没有得到句柄;自然UpdateWindow()也没有调用;

## `1.2 消息解读`
`hWnd`
窗口句柄;
`uMsg`
WM_CREATE;
`wParam`
末使用;
`lParam`
指向CREATESTRUCT结构的指针,其中包含有关正在创建的窗口的信息;

## `1.3 作用`
1. 主窗口创建了,我们就可以在WM_CREATE的代码块里,创建其它资源: 子窗口 & 控件 & 菜单 & 图标 & 位图 & ...; 注意,最好只创建,不要使用,因为主窗口还没有显示;

## `1.4 注意`
消息只是创建资源,不要使用资源哦(视情况而定);

# `2. WM_DESTROY`
## `1.1 何时发送`
窗口被销毁时发送;窗口从屏幕上移除后,它被发送到正在销毁的窗口的窗口过程。
该消息首先发送到被销毁的窗口,然后发送到子窗口(如果有的话)因为它们也要被销毁。

## `2.2 消息解读`
`hWnd`
窗口句柄;
`uMsg`
WM_DESTROY;
`wParam`
末使用;
`lParam`
末使用;

## `2.3 作用`
1. 主窗口都要被销毁了,程序也应该退出了,所以PostQuitMessage();
2. 可以在这里释放资源,与WM_CREATE相呼应;

## `2.4 注意`
如果不在代码块里发送退出程序消息,程序是不会退出的;
DestroWindow()函数发出了WM_DESTROY消息,所以不要在里面调用这个函数;

# `3. WM_PAINT`
## `1.1 何时发送`
当系统或一个程序请求绘制另一个程序的窗口时发送;
当UpdateWindow() or RedrawWindow()被调用,这个消息被发送;
当GetMessage()得到这个消息;

## `3.2 消息解读`
`hWnd`
窗口句柄;
`uMsg`
WM_PAINT;
`wParam`
末使用;
`lParam`
末使用;

## `3.3 作用`
绘制窗口前景;

## `3.4 注意`

# `4. WM_ERASEBKGND`
## `4.1 何时发送`
必须擦除窗口背景时发送（例如，调整窗口大小时）。该消息被发送以准备用于绘画的无效部分的窗口;

## `4.2 消息解读`
`hWnd`
窗口句柄;
`uMsg`
WM_ERASEBKGND;
`wParam`
设备上下文的句柄;
`lParam`
末使用;
## `4.3 作用`

在绘制前景之前,先绘制背景;

## `4.4 注意`

# `5. WM_COMMAND`
## `5.1 何时发送`
当用户从菜单中选择命令项时 & 控件向其父窗口发送通知消息 & 热键时 发送;

## `5.2 消息解读`
`hWnd`
窗口句柄;
`uMsg`
WM_COMMAND;
`wParam`
见注意;
`lParam`
见注意;
## `5.3 作用`

1. 响应菜单命令;
2. 响应控件通知消息;
3. 响应热键;

## `5.4 注意`
| 消息来源 | wParam（高字）     | wParam（低字）       | lParam       |
| -------- | ------------------ | -------------------- | ------------ |
| 菜单     | 0                  | 菜单标识符（IDM_ *） | 0            |
| 热键     | 1                  | 热键标识符（IDM_ *） | 0            |
| 控件     | 控件定义的通知代码 | 控件标识符           | 控件窗口句柄 |

# `6. WM_TIMER`
## `6.1 何时发送`
当计时器到期时,发送到安装线程的消息队列;该消息由GetMessage()或PeekMessage()发送;

## `6.2 消息解读`
`hWnd`
窗口句柄;
`uMsg`
WM_TIMER;
`wParam`
定时器标识符;
`lParam`
指向安装了定时器时传递给SetTimer函数的应用程序定义的回调函数的指针;

## `6.3 作用`
定时做任务;

## `6.4 注意`
您可以通过在窗口过程中提供WM_TIMER情况来处理消息。否则，DispatchMessage将调用在用于安装定时器的SetTimer函数调用中指定的TimerProc回调函数。

WM_TIMER消息是一个低优先级的消息。只有在线程的消息队列中没有其他更高优先级的消息时，GetMessage和PeekMessage函数才会发送此消息。

# `7. 作业`
1. 上节课我们用的是默认的按钮类,现在大家手动实现按钮类;完成新的计时器; (必做)
2. 思考它们的区别;