***
[TOC]
***

# `1. windows消息`

> windows消息，就是指Windows发出的一个通知，告诉应用程序某个事情发生了。例如，单击鼠标、改变窗口尺寸、按下键盘上的一个键都会使Windows发送一个消息给应用程序。消息本身是作为一个记录传递给应用程序的，这个记录中包含了消息的类型以及其他信息。例如，对于单击鼠标所产生的消息来说，这个记录中包含了单击鼠标时的坐标。这个记录类型叫做MSG.

## `1.1 消息系统`
Windows的消息系统是由3个部分组成的：
- 消息队列: Windows能够为所有的应用程序维护一个消息队列。应用程序必须从消息队列中获取消息，然后分派给某个窗口。
  当windows应用程序开始执行时,系统会为该程序建立一个消息队列用于存放消息,然后用getmessage等进行消息获取处理。程序从队列中获取消息后处理.

- 消息循环: 通过这个循环机制应用程序从消息队列中检索消息，再把它分派给适当的窗口，然后继续从消息队列中检索下一条消息，再分派给适当的窗口，依次进行。
- 窗口过程: 每个窗口都有一个窗口过程来接收传递给窗口的消息，它的任务就是获取消息然后响应它。窗口过程是一个回调函数；处理了一个消息后，它通常要返回一个值给Windows。

## `1.2 消息分类`

1. 系统定义消息(System-Defined Messages)
   1. 标准消息: 除WM_COMMAND之外,所有以WM_开头的消息都是标准消息，例如鼠标单击、移动，键盘左击、右击。
   2. 命令消息: 来自菜单，加速键或工具栏按钮的消息。这类消息都以WM——COMMAND形式呈现。WM_COMMAND, LOWORD(wParam)表示菜单项，工具栏按钮或一般控件的ID如编辑框，按钮等。如果是控件, HIWORD(wParam)表示控件消息类型.
   3. 通告消息: 由复杂控件产生的消息。这类消息也是以WM_COMMAND形式呈现。 这是最灵活的消息格式， 其Message, wParam, lParam分别为：WM_NOTIFY, 控件ID，指向NMHDR的指针。NMHDR包含控件通知的内容,可以任意扩展.
2. 程序定义消息(Application-Defined Messages) 
   用户自定义的消息: 对于其范围有如下规定： WM_USER: 0x0400-0x7FFF (ex. WM_USER+10)

##　`1.3 MSG结构体`

```
typedef struct tagMSG {
	 HWND        hwnd;    //指定消息所处的窗口
	 UINT        message; //指定消息的标识符 （宏定义处理方便）
	 WPARAM      wParam;  //MSG的附加消息
	 LPARAM      lParam;  //附加消息
	 DWORD       time;    //投递到消息队列的事件
	 POINT       pt;      //投递时鼠标当前位置
} MSG
```

# `2. 消息获取/发送函数`

```
BOOL WINAPI GetMessage(
  _Out_    LPMSG lpMsg,
  _In_opt_ HWND  hWnd,
  _In_     UINT  wMsgFilterMin,
  _In_     UINT  wMsgFilterMax
);

BOOL WINAPI PeekMessage(
  _Out_    LPMSG lpMsg,
  _In_opt_ HWND  hWnd,
  _In_     UINT  wMsgFilterMin,
  _In_     UINT  wMsgFilterMax,
  _In_     UINT  wRemoveMsg
);

GetMessage-从消息队列中获取一个消息后移除(堵塞),当队列中无消息获取则等候下一个消息
PeekMessage---查看消息队列中消息,非堵塞,无消息是返回false
```



```
LRESULT WINAPI SendMessage(
  _In_ HWND   hWnd,
  _In_ UINT   Msg,
  _In_ WPARAM wParam,
  _In_ LPARAM lParam
);

BOOL WINAPI PostMessage(
  _In_opt_ HWND   hWnd,
  _In_     UINT   Msg,
  _In_     WPARAM wParam,
  _In_     LPARAM lParam
);

SendMessage--把消息发送到指定窗口,直接消息处理函数处理,获取到返回结果后结束(堵塞)
PostMessage--将消息放入指定窗口消息队列,不等待结果直接返回(非堵塞)
```

# `3. 消息处理过程`

> WNDPROC WNDCLASS::lpfnWndProc 是我们消息的处理中心,所以我们要对这个函数指针变量格外了解.现在让我们全面的了解它吧.

> 从当前程序的消息队列中进行查找,如果有消息则判断是否满足窗口句柄,id范围等条件.满足的话取出消息发送给消息处理函数后返回,如果不满足则向系统消息队列获取属于本进程的消息,如果找到满足条件的则把系统中消息队列中的存入本程序消息队列中.如果系统消息队列也没有则检查窗口是否重绘,是则产生WM_PAIT消息,然后返回处理,如果没有重绘,查看定时器有没有需要处理,有则产生WM_TIMER消息.如果没定时器则优化资源,处理内存.然后等候下一个消息(PEEKmessage不会等待,会直接返回false后交出程序的控制权)

> 处理过程：查找本程序消息-->如果消息队列有则判断是否满足条件(ID)-—>满足取出消息(不满足不取)-->查窗口相关系统消息（如无程序消息）-->转去程序消息(如有)-->检查重绘(如无系统消息)---->发送wm_paint消息-->检查定时器(如无重画)-->整理程序资源内存-->等待


# `4. 重要的消息`

## `WM_CREATE`
> 当应用程序通过调用CreateWindowEx或CreateWindow函数请求创建窗口时发送。（消息在函数返回之前发送。）新窗口的窗口过程在创建窗口后但在窗口变为可见之前接收到此消息。

> 一个窗口通过它的WindowProC函数接收这个消息。 

> 可以在WM_CREATE的响应代码块里,创建它拥有的资源.

## `WM_PAINT`

> 当系统或另一个应用程序,请求绘制应用程序窗口的部分时,消息被发送。该消息在UpdateWindow或RedrawWindow函数被调用时发送，或者在应用程序通过使用GetMessage或PeekMessage函数获取WM_PAINT消息时由DispatchMessage函数发送。

> 可以在WM_PAINT的响应代码块里,绘制窗口的客户区.

## `WM_TIMER`

> 当计时器到期时，传递到安装线程的消息队列。该消息由GetMessage或PeekMessage函数投递。

> 可以在WM_TIMER的响应代码块里,做计时任务.
```
UINT_PTR WINAPI SetTimer( HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc);
BOOL WINAPI KillTimer( HWND hWnd, UINT_PTR uIDEvent);
```

## `WM_EREASEBKGND`

> 当窗口背景必须被擦除时 （例如，窗口的移动，窗口的大小的改变）才发送。
> 当窗口的一部分无效需要重绘时发送此消息。

> 如果应用程序响应处理**WM_ERASEBKGND**消息并擦除背景，应返回非零值 ；告诉Windows没有必要再擦除。如果应用程序返回零，Windows仍将标记为删除。 

## `WM_COMMAND`

> 菜单 & 控件 & 热键 可以发出此消息.

| 消息来源 | wParam（高字）     | wParam（低字）       | lParam的     |
| -------- | ------------------ | -------------------- | ------------ |
| 菜单     | 0                  | 菜单标识符（IDM_ *） | 0            |
| 热键     | 1                  | 热键标识符（IDM_ *） | 0            |
| 控件     | 控件定义的通知代码 | 控件标识符           | 控件窗口句柄 |

# `5. 作业`
作业: 做一个计时器,要有三个按钮: 开始 & 暂停 & 停止.  (必做)

```
1. 创建按钮: 在主窗口的WM_CREATE消息中
hwndButtonCintinue=CreateWindow(TEXT("button"),//必须为：button    
        L"继续导入", //按钮上显示的字符    
        WS_CHILD | WS_VISIBLE,  
        100,240,100,50,  //按钮在界面上出现的位置
        hWnd,(HMENU)IDC_BUTTON_CONTINUE,  //设置按钮IDIDC_BUTTON_CONTINUE = 131自己定义ID
        ((LPCREATESTRUCT)lParam)->hInstance,
        NULL); 
2. 响应按钮: WM_COMMAND消息;
```



音乐播放器的按钮就解决了.