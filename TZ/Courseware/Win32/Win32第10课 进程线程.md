***
`Version:` 
`Declaration:` 
`Defination:` 
`Reference:` 
`Keyword:` 

***
[TOC]
***

# `1. 进程`

## `1.1 进程定义`
进程是一个容器，是正在运行的程序，即程序的运行实例。也可以叫做一段程序的执行过程。
包含程序执行需要的代码、数据、资源等等信息。Windows是多任务操作系统，可以同时执行多个进程。

## `1.2 Windows进程的特点`
- 每个进程都有自己的ID号
- 每个进程都有自己的地址空间，进程之间无法访问对方的地址空间。
- 每个进程都有自己的安全属性
- 每个进程当中至少包含一个线程

## `1.3 进程的id和句柄`
获取当前进程ID:     DWORD GetCurrentProcessId()
得到当前进程的句柄: HANDLE GetCurrentProcess();

## `1.4 创建进程`
```
BOOL WINAPI CreateProcess(
  _In_opt_ LPCTSTR lpApplicationName,                    //进程路径
  _Inout_opt_ LPTSTR lpCommandLine,                      //命令行参数
  _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,    //进程安全属性
  _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,     //线程安全属性
  _In_ BOOL bInheritHandles,                             //进程的句柄继承
  _In_ DWORD dwCreationFlags,                            //创建方式
  _In_opt_ LPVOID lpEnvironment,                         //环境信息
  _In_opt_ LPCTSTR lpCurrentDirectory,                   //当前目录
  _In_ LPSTARTUPINFO lpStartupInfo,                      //起始信息
  _Out_ LPPROCESS_INFORMATION lpProcessInformation       //进程句柄
);
```
```
STARTUPINFO si{};
PROCESS_INFORMATION pi{};
CreateProcess(L"Csl-0.exe", 0, 0, 0, 0, CREATE_NEW_CONSOLE, 0, 0, &si, &pi);
```

`获取进程id和进程名`
EnumProcesses  	     -----获取所有进程id

```
DWORD dwArr[1024]{}, dwRetSize{};
EnumProcesses(dwArr, 1024 * 4, &dwRetSize);
```

EnumProcessModules   -----根据句柄获取模块化句柄

```
HMODULE hArr[1024]{};
DWORD dwRetSize{};
EnumProcessModules(GetCurrentProcess(), hArr, 1024 * 4, &dwRetSize);
```

GetModuleBaseName    -----根据模块句柄得到模块名

```
HMODULE hMod = GetModuleHandle(0);
assert(hMod);
WCHAR wcsTmp[MAX_PATH]{};
GetModuleBaseName(GetCurrentProcess(), hMod, wcsTmp, MAX_PATH);
```

`打开进程/获取当前进程的真正句柄`
```
HANDLE OpenProcess(
    DWORD dwDesiredAccess, //访问模式
    BOOL bInheritHandle,   //继承标识
    DWORD dwProcessId      //进程ID
);
```

## `1.5 等待进程结束`
WaitForSingleObject()

## `1.6 打开进程—得到进程句柄`
```
HANDLE OpenProcess(
DWORD dwDesiredAccess, //打开权限PROCESS_ALL_ACCESS
BOOL  bInheritHandle,  //继承方式
DWORD dwProcessId      //进程id
);

OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());
```

## `1.7 结束当前进程`
ExitProcess()

## `1.8 结束指定进程`
TerminateProcess()

```
int main()
{
	STARTUPINFO si{};
	PROCESS_INFORMATION pi{};
	assert(CreateProcess(L"Csl-0.exe", 0, 0, 0, 0, CREATE_NEW_CONSOLE, 0, 0, &si, &pi));
	assert(pi.hProcess);
	Sleep(2000);

	TerminateProcess(pi.hProcess, 0); //如果要结束进程在system("pause");效果中,是不会马上结束程序的;

	system("pause");

	return 0;
}
```
# `2. 线程`

## `2.1 线程定义`
windows以线程为单位进行调度程序，一个程序中至少有一个线程
可以有多个线程，用来实现多任务的处理

## `2.2 线程特点`
- 线程都有一个id
- 线程都具有自己的安全属性
- 线程都有自己的内存栈
- 线程都有自己的寄存器信息

## `2.3 创建线程:`
```
HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES lpT,  //安全属性
    SIZE_T dwStackSize,         //线程栈大小
    LPTHREAD_START_ROUTINE lp,  //线程处理函数
    LPVOID lpParameter,         //处理函数参数
    DWORD dwCreationFlags,      //创建方式
    LPDWORD lpThreadId          //线程id    
    );
```

这个函数不是线程安全的,一般用_beginthreadex.

## `2.4 线程处理函数`
DWORD  WINAPI Threadproc(LPVOID lp){}

## `2.5 结束线程`
```
BOOL TerminateThread( HANDLE hThread,DWORD dwExitCode);
VOID ExitThread(DWORD dwExitCode);
closeHandle();
```

```
#include <windows.h>
#include <process.h>
#include <stdio.h>


unsigned __stdcall ThreadProc1(void*);
unsigned __stdcall ThreadProc2(void*);

int main()
{
	HANDLE hThreadArr[2]{};
	hThreadArr[0] = (HANDLE)_beginthreadex(0, 0, &ThreadProc1, 0, 0, 0);
	hThreadArr[1] = (HANDLE)_beginthreadex(0, 0, &ThreadProc2, 0, 0, 0);

	TerminateThread(hThreadArr[1], 0);
	WaitForMultipleObjects(2, hThreadArr, true, INFINITE);

	system("pause");


	return 0;
}

unsigned __stdcall ThreadProc1(void *)
{
	for (int i = 0; i < 10; i++)
		printf("ThreadProc1 : %d \n", i);

	ExitThread(0);

	printf("ThreadProc1 end");

	return 0;
}

unsigned __stdcall ThreadProc2(void*)
{
	while (true);

	return 0;
}
```

## `2.6 等候进程结束`

```
DWORD WaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds);
DWORD WaitForMultipleObjects( DWORD nCount, CONST HANDLE * lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
```

# `3. 作业`

1. 在一个程序内,写三个线程,内部是自加同一全局变量10000次. 完成后打印出全局变量结果. (必做)

2. 改进程序:

   - 当线程1自加了8000次时,自结束;
   - 当线程1结束后,结束线程2;
   - 当线程1 2结束后,结束线程3;
   - 当线程1 2 3结束后,打印出全局变量结果;

3. 第一个程序的结果对么,如果有问题,请尝试解决;

   
