***
[TOC]
***



# `1. 目录操作`

| Funcs               | Description      |
| ------------------- | ---------------- |
| GetCurrentDirectory | 得到当前工作目录 |
| GetModuleFileName   | 得到模块文件名   |
| SetCurrentDirectory | 设置当前工作目录 |
| GetWindowsDirectory | 得到windows目录  |
| GetSystemDirectoy   | 得到system目录   |
| GetTempPath         | 得到temp目录     |



# `2. 文件操作`

## `2.1 打开文件`

```
HANDLE WINAPI CreateFile(
  _In_     LPCTSTR               lpFileName,             //文件名
  _In_     DWORD                 dwDesiredAccess,        //期望的权限
  _In_     DWORD                 dwShareMode,            //共享模式
  _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,   //安全属性
  _In_     DWORD                 dwCreationDisposition,  //创建配置
  _In_     DWORD                 dwFlagsAndAttributes,   //标志与属性
  _In_opt_ HANDLE                hTemplateFile           //模板文件句柄
);
```



## `2.2 关闭文件`

```
BOOL WINAPI CloseHandle(_In_ HANDLE hObject);
```

## `2.4 写入文件`

```
BOOL WINAPI WriteFile(
  _In_        HANDLE       hFile,                    //文件句柄 
  _In_        LPCVOID      lpBuffer,                 //要写入的字符串
  _In_        DWORD        nNumberOfBytesToWrite,    //要写入的字节数
  _Out_opt_   LPDWORD      lpNumberOfBytesWritten,   //写入成功的字节数
  _Inout_opt_ LPOVERLAPPED lpOverlapped              //与异步有关
);
```

## `2.5 读取文件`

```
BOOL WINAPI ReadFile(
  _In_        HANDLE       hFile,                 //文件句柄 
  _Out_       LPVOID       lpBuffer,              //要读入的字符串
  _In_        DWORD        nNumberOfBytesToRead,  //要读入的字节数
  _Out_opt_   LPDWORD      lpNumberOfBytesRead,   //读入成功的字节数
  _Inout_opt_ LPOVERLAPPED lpOverlapped           //与异步有关
```

## `2.3 得到文件尺寸`

```
DWORD WINAPI GetFileSize(_In_ HANDLE hFile, _Out_opt_ LPDWORD lpFileSizeHigh);
```

## `2.6 文件指针偏移`

```
DWORD WINAPI SetFilePointer(
  _In_        HANDLE hFile,					//文件句柄
  _In_        LONG   lDistanceToMove,		  //移动距离低32位
  _Inout_opt_ PLONG  lpDistanceToMoveHigh,	   //移动距离高32位
  _In_        DWORD  dwMoveMethod			 //移动方法
);
```

## `2.7 拷贝文件`

```
BOOL WINAPI CopyFile(
  _In_ LPCTSTR lpExistingFileName,       //源文件名
  _In_ LPCTSTR lpNewFileName,            //新文件名
  _In_ BOOL    bFailIfExists             //指定的新文件名如果存在,怎么处理? MSDN
);
```

## `2.8 删除文件`

```
BOOL WINAPI DeleteFile(_In_ LPCTSTR lpFileName);
```

## `2.9 移动文件`

```
BOOL WINAPI MoveFile(
  _In_ LPCTSTR lpExistingFileName,    //源文件名
  _In_ LPCTSTR lpNewFileName          //新文件名
);
```

# `3. 文件查找`

## `3.1 文件查找结构体`

```
typedef struct _WIN32_FIND_DATA {
  DWORD    dwFileAttributes;        //文件属性
  FILETIME ftCreationTime;          //创建时间
  FILETIME ftLastAccessTime;        //最后访问时间
  FILETIME ftLastWriteTime;         //最后写时间
  DWORD    nFileSizeHigh;           //文件尺寸高32位
  DWORD    nFileSizeLow;            //文件尺寸低32位
  DWORD    dwReserved0;             //保留,MSDN
  DWORD    dwReserved1;             //保留
  TCHAR    cFileName[MAX_PATH];     //文件名
  TCHAR    cAlternateFileName[14];  //文件另一个名
} WIN32_FIND_DATA, *PWIN32_FIND_DATA, *LPWIN32_FIND_DATA;
```

## `3.2 文件查找函数`

```
HANDLE WINAPI FindFirstFile(
  _In_  LPCTSTR           lpFileName,
  _Out_ LPWIN32_FIND_DATA lpFindFileData
);
```



```
BOOL WINAPI FindNextFile(
  _In_  HANDLE            hFindFile,
  _Out_ LPWIN32_FIND_DATA lpFindFileData
);
```

```
BOOL WINAPI FindClose(_Inout_ HANDLE hFindFile);
```

## `3.3 代码`

```
#include <windows.h>
#include <assert.h>
#include <string>
#include <vector>
#include <iostream>

using namespace std;


typedef struct _DIRETORY_CONTENT_INFO DIR_CONTENT_INFO, *PDIR_CONTENT_INFO;
struct _DIRETORY_CONTENT_INFO
{
	int iDeep = -1;						 //当前目录深度
	static int iFileCounter;                 //文件计数器
	wstring wcsDir{};                        //目录
	vector<PDIR_CONTENT_INFO> vctDCI{};	     //目录的目录
	vector<wstring> vctFile{};               //目录的文件

	~_DIRETORY_CONTENT_INFO();
};
int DIR_CONTENT_INFO::iFileCounter{};

DIR_CONTENT_INFO g_dci{};

void EnumDir(DIR_CONTENT_INFO& dci);
void Show(const DIR_CONTENT_INFO& dci);


int main()
{
	DIR_CONTENT_INFO dci{};
	dci.wcsDir = L"C:\\Program Files\\Windows Media Player\\";

	EnumDir(dci);
	Show(dci);

	system("pause");

	return 0;
}

void EnumDir(DIR_CONTENT_INFO & dci)
{
	dci.iDeep++;
	wstring wcsFileName = dci.wcsDir + L"*";
	
	WIN32_FIND_DATA wfd{};
	HANDLE hFile = FindFirstFile(wcsFileName.c_str(), &wfd);
	assert(hFile != INVALID_HANDLE_VALUE);

	do
	{
		// 1.如果为本目录,上级目录
		if (wcscmp(wfd.cFileName, L".") == 0 || wcscmp(wfd.cFileName, L"..") == 0)
			continue;

		// 2.如果是文件
		if (!(wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		{
			dci.vctFile.push_back(wfd.cFileName);
			DIR_CONTENT_INFO::iFileCounter++;
			continue;
		}

		// 3.如果是目录
		{
			wstring wcsDir = wfd.cFileName;
			wcsDir += L"\\";
			PDIR_CONTENT_INFO pDCI = new DIR_CONTENT_INFO{};
			pDCI->iDeep = dci.iDeep;
			pDCI->wcsDir = dci.wcsDir + wcsDir;
			dci.vctDCI.push_back(pDCI);
			EnumDir(*pDCI);
		}

	} while (FindNextFile(hFile, &wfd));
	FindClose(hFile);
}

void Show(const DIR_CONTENT_INFO & dci)
{
	//输出目录
	for (int i = 0; i < dci.iDeep * 4; i++)
		cout << " ";

	wprintf(dci.wcsDir.c_str());
	wprintf(L"\n");

	//遍历子目录
	for (int i = 0; i < dci.vctDCI.size() ; i++)
		Show(*dci.vctDCI.at(i));

	//输出文件
	for (int i = 0; i < dci.vctFile.size() ; i++)
	{
		for (int i = 0; i < (dci.iDeep + 1) * 4; i++)
			cout << " ";

		wprintf(dci.vctFile.at(i).c_str());
		wprintf(L"\n");
	}
}

_DIRETORY_CONTENT_INFO::~_DIRETORY_CONTENT_INFO()
{
	for (int i = 0; i < vctDCI.size() ; i++)
		delete vctDCI.at(i);
}
```


# `4. 文件映射`

`Reference:`  https://msdn.microsoft.com/en-us/library/windows/desktop/aa366556(v=vs.85).aspx

`关键字:` File Mapping

# `5. 作业`

1. 把音乐文件名(全路径名)写入到文件中. (必做)
2. 用文件初始化文件列表. (选做)