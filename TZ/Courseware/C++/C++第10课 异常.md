***
[TOC]
***

# `1. 异常机制`

> 程序设计的要求之一就是程序的健壮性。希望程序在运行时能够不出或者少出问题。但是，在程序的实际运行时，总会有一些因素导致程序不能正常运行。

> 在设计算法时，往往对算法的正常逻辑处理流程设计得比较准确，对异常情况的处理反而不容易设计全面，导致程序在出现异常情况时崩溃。如果软件出现这种情况会给用户带来极不友好的体验。

> 异常处理是一种允许两个独立开发的程序组件在程序执行期间遇到程序不正常的情况(异常exception)时相互通信的机制.

> 在C++中，使用try、throw、catch三个关键字来实现异常处理。
> try: 指定可能异常的语句块.
> catch: 捕捉&处理异常的语句块.
> throw: 抛出异常.

> try
> {
>  	// 保护代码
> }
>
> catch( ExceptionName e1 )
> {
>  	// catch 块
> }
>
> catch( ExceptionName e2 )
> {
>  	// catch 块
> }
>
> catch( ExceptionName eN )
> {
>  	// catch 块
> }


`使用例子`
```
#include <exception>
#include <iostream>

using namespace std;

class CDvdException : public exception
{
public:
	explicit CDvdException();
};

//除法
int Dvd(int l, int r);

int main()
{
	int a{}, b{};
	try
	{
		a = Dvd(3, b);
	}
	catch (CDvdException& e)
	{
		cout << e.what() << endl;
	}

	return 0;
}

int Dvd(int l, int r)
{
	if (!r)
		throw CDvdException();

	return l / r;
}

CDvdException::CDvdException() : exception("Zero exception occurs !")
{
}
```



# `2. 异常类`

> C++ 提供了一系列标准的异常，定义在 **<exception>** 中，我们可以在程序中使用这些标准的异常.

| 类名 | 详细 |
| ---------------------- | ------------------------------------------------------------ |
| exception     | 该异常是所有标准 C++ 异常的父类。                            |
| bad_alloc         | 该异常可以通过 **new** 抛出。                                |
| bad_cast          | 该异常可以通过 **dynamic_cast** 抛出。                       |
| bad_exception     | 这在处理 C++ 程序中无法预期的异常时非常有用。                |
| bad_typeid        | 该异常可以通过 **typeid** 抛出。                             |
| logic_error   | 理论上可以通过读取代码来检测到的异常。                       |
| domain_error      | 当使用了一个无效的数学域时，会抛出该异常。                   |
| invalid_argument  | 当使用了无效的参数时，会抛出该异常。                         |
| length_error      | 当创建了太长的 std::string 时，会抛出该异常。                |
| out_of_range      | 该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator\[]()。 |
| runtime_error | 理论上不可以通过读取代码来检测到的异常。                     |
| overflow_error    | 当发生数学上溢时，会抛出该异常。                             |
| range_error       | 当尝试存储超出范围的值时，会抛出该异常。                     |
| underflow_error   | 当发生数学下溢时，会抛出该异常。                             |

# `3. c++11标准`

> 官网: https://isocpp.org

>C++的4个次语言:
>
>`C : `         
>
>C++以C为基础。区块(blocks)、语句(statements)、预处理器(preprocessor)、内置数据类型(built-in data types)、数组(arrays)、指针(pointers)等都来自C。
>
>`Object-oriented C ++ :   `     
>
>类(class)、封装(encapsulation)、继承(inheritance)、多态(polymorphism)、虚函数(virtual function)等都是面向对象设计在C++上的最直接实施。
>
>`Template C++ (generic programming) :   `     
>
>C++的范型编程(generic programming)部分。他们带来新的编程范型(programming paradigm)，也就是所谓的template meta programming(TMP，模板元编程)。
>
>`STL: `       
>
>即template程序库，对容器、迭代器、算法以及函数对象的规约有极佳的紧密配合与协调。

## `3.1 定义变量初始化`

```
int n = 10;
int n(10);
int n{10};
```

## `3.2 nullptr`

比NULL更安全,解决二义性;

```
int fun(int a, int* p) { return a; }
int fun(int a, int b) { return a; }

int main()
{
	//fun(1, 0);
	fun(1, nullptr);

	return 0;
}
```



## `3.3 auto 自适应类型`

```
auto n = 1;
auto m = 1.0;
```

## `3.4 decltype 类型声明`
```
int i = 10;
decltype(i) x = i; 		//类似 int x = i;
decltype((i)) y = i; 	//类似 int& y = i;	双括号是引用
y = 20;
```

## `3.5 for新用法`
```
char str[] = "123456";
for (auto s : str)
	printf("%c", s);
```

## `3.6 类型取别名`
```
typedef int*(*PFUN)();		//类型
using PFUN = int*(*)();		//类型
```

## `3.7 类中成员直接初始化`

## `3.8 类的默认`
```
A()  = default;
```

## `3.9 构造器委托`
当前类中委托当前构造器做事情
自己的构造函数调用自己的构造函数

## `3.10 final 关键字`
final 与 override 是相反的,它禁止子类覆盖虚函数.

# `4. 强制类型转换`

## `4.0 资料`
`const_cast:`  http://zh.cppreference.com/w/cpp/language/const_cast
`static_cast`  http://zh.cppreference.com/w/cpp/language/static_cast
`reinterpret_cast` http://zh.cppreference.com/w/cpp/language/reinterpret_cast
`dynamic_cast:`  http://zh.cppreference.com/w/cpp/language/dynamic_cast

## `4.1 const_cast`
> 在有不同 cv 限定的类型间转换。

> 只能对指针或者引用去除或者添加const属性，对于变量直接类型不能使用const_cast；不能用于不同类型之间的转换，只能改变同种类型的const属性。 

```
常用方式:
1. 常用于函数的形参是一个非const的引用: 可以使用const_cast<type&>param;去除实参的常量性，以便函数能够接受这个参数。
2. 一个const对象,我们想要调用该对象中的非const函数,可以使用const_cast去除对象的常量性;
```



## `4.2 static_cast`
> 进行基本转换
> 用隐式和用户定义转换的组合在类型间转换。
```
常用方式:
1. 基本数据类型之间的转换
2. 派生体系中向上转型: 将派生类指针或引用转化为基类指针或引用;
```



## `4.3 reinterpret_cast`

> 通过转译底层位模式在类型间转换。
## `4.4 dynamic_cast`
> 进行有检查的多态转换
> 沿继承层级向上、向下及侧向转换到类的指针和引用

```
执行派生类指针或引用与基类指针或引用之间的转换

1. 其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行运行时类型检查；
2. 基类中要有虚函数，因为运行时类型检查的类型信息在虚函数表中，有虚函数才会有虚函数表；
3. 可以实现向上转型和向下转型，前提是必须使用public或protected继承；
4. 真实对象要是子类;
```

## `4.5 总结`

1. const_cast主要是用来去掉指针和引用的const和volatile类型。
2. static_cast会进行静态的安全性检查，一般用于内置数据类型的转换和通常的类之间的转换。
3. reinterpret_cast用于完全没有关系指针或引用之间的转换，比如字符指针转整形指针。
4. dynamic_cast通常用于基类和派生类之间的相互转换。


# `5. 作业`

1. 完整版俄罗斯方块. (必做)
2. 自己动手写贪食蛇. (选做)

