***
[TOC]
***

# `0. 本课目标`

1. 了解泛型与模板;
1. 使用模板;
2. 改造以前的vector;

# `1. 模板和泛型`

## `1.1 泛型`
### `1.1.1 问题`
我们以前都写过vector,但是他有一个致命的缺陷,那就是元素的类型是固定的;
有没有一种方式让代码不依赖于类型?
这种类型就是我们今天要学的泛型了;
### `1.1.2 简述`
> 泛型是程序设计语言的一种特性。允许程序员在强类型程序设计语言中编写代码时定义一些==可变==部分，那些部分在==使用前==必须作出指明。各种程序设计语言和其编译器、运行环境对泛型的支持均不一样。==将类型参数化以达到代码复用提高软件开发工作效率的一种数据类型。==

## `1.1.3 泛型的优缺`
`优`
1. 使用泛型类型可以最大限度地重用代码;
2. 保护类型的安全;
3. 提高性能;

`缺`
1. 在性能上不如数组快;
2. 代码膨胀, ==现在的编译器都会尝试合并template里的代码段的;只是大量用模板,编译速度慢不少==

## `1.2 模板`
## `1.2.1 问题`
如果要我写`Int` `short` `long long` 类型的加法函数,会有三个函数;
如果要我写`Int` `short` `long long` 类型的vector,会有三个vector类;
有没有解决办法?
下面我们来学习如何解决这个问题;

## `1.2.2 简述`
> 模板就是实现代码重用机制的一种工具,它可以实现类型参数化,即把类型定义为参数,从而实现了真正的代码可重用性;

> 泛型是可变类型的理论,而C++模板是泛型的具体实现;

> 模版可以分为两类:一个是函数模版,另外一个是类模版;

# `2. 函数模板`
## `2.1 简述`
> 函数模板==不是==一个实在的函数,编译器==不能==为其生成可执行代码;==定义函数模板后只是一个对函数功能框架的描述==,当它具体执行时,==将根据传递的实际参数决定其功能;==

## `2.2 声明`
```
template<typename T1, ..., typename Tn>
返回类型 函数名(形式参数表);
```
## `2.3 定义`
```
template<typename T1, ..., typename Tn>
返回类型 函数名(形式参数表)
{
    //函数体
}
```

## `2.4 使用`
```
template<typename T>			  //声明函数的泛型
T Add(T l, T r);	    		  //声明函数,可以使用泛型了

int main()
{
    int i = Add(1, 2);               //这个Add函数的地址是?
    short s = Add(1, 2);             //这个Add函数的地址是?
    double d = Add(1, 2);            //这个Add函数的地址是?

    s = Add((short)1, (short)2);     //这个Add函数的地址是?
    d = Add((double)1, (double)2);   //这个Add函数的地址是?

    return 0;
}

template<typename T>			   //定义函数,定要带上泛型的声明
T Add(T l, T r)
{
    return l + r;
}
```

# `3. 模板函数`

> 模板函数是一个实在的函数;当我们调用函数模板,在编译时,会泛型确认函数代码,这个函数就是模板函数;

# `4. 显式调用和隐式调用`
> 有一些函数,你主动的调用了,就是显示调用.
如果你没有调用,但是这个函数确实被调用了,那它就是被隐式的调用了.
一般来说,强制转换是隐式调用了构造函数.
析构函数是隐式调用的,不需要我们主动调用.

```
#include <iostream>

using namespace std;

class CInt
{
private:
	int m_i{};

public:
	CInt();
	CInt(char ch);
	CInt(short s);
	CInt(double d);

	~CInt();

	int GetInt() { return m_i; }
};

int Add(int l, CInt r);

int main()
{
	Add(1, 'a');		//隐式调用CInt(char ch);
	Add(1, (short)2);	 //隐式调用CInt(short s);
	Add(1, 1.0);		//隐式调用CInt(double d);

	return 0;
}

CInt::CInt()
{
	m_i = 0;
}

CInt::CInt(char ch)
{
	m_i = ch;
}

CInt::CInt(short s)
{
	m_i = s;
}

CInt::CInt(double d)
{
	m_i = d;
}

CInt::~CInt()
{
	cout << "~CInt" << endl;
}

int Add(int l, CInt r)
{
	return l + r.GetInt();
}
```

# `5. 类模板`
## `5.1 简述`
> 是对一批仅仅成员数据类型不同的类的抽象;程序员只要为这一批类所组成的整个类家族创建一个类模板,给出一套程序代码,就可以用来生成多种具体的类,从而大大提高编程的效率;

## `5.2 声明`

```
template <typename T1, ... , typename Tn>
class 类名
{
    //类体
}
```



## `5.3 定义`

> 成员函数的定义要加上`template <typename T1, ... , typename Tn>`;

## `5.4 使用`

```
#include <iostream>

using namespace std;

template <typename T>
class CVector
{
private:
	T m_data;
public:

	CVector(T o) { m_data = o; }
	void Output() { cout << m_data << endl; }
};

int main()
{
	CVector<int> vctInt(1);
	vctInt.Output();
	CVector<char> vctChar('a');
	vctChar.Output();
	CVector<double> vctDbl(1.0);
	vctDbl.Output();

	return 0;
}
```

# `6. 模板类`

> 模板类是一个实在的类;当我们调用类模板定义对象,在编译时,会泛型确认类代码,这个类就是模板类;

# `7. 作业`

1. 完成第10课的作业.