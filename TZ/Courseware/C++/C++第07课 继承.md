***
[TOC]
***

# `1. 继承与派生`
# `1.1 简述`
> 继承是子类得到父类的能力(属性与函数);
> 在基类上建立的新类称为子类;

> 子类继承了父类,父类派生了子类.二种不同的说法;

> 游戏中,人物与终极BOSS有很多相同的地方: 有血量blood & 有武器weapon & 有攻击力ATK;
> 但是也有不一样的地方: 人物有包裹pack, 有血瓶blood vial; Boss有秒杀技seckill skill;
>
> 
>
> 所以我们可以这样设计:
>
> 1. 父类: 动物animal
> 2. 子类: 人类humam   终极BOSS

## `1.2 声明`

> 与第三课类的声明相同;

## `1.3 定义`

```
class关键字  子类名  :  <派生方式>  父类名1, <派生方式>  父类名2, ... , <派生方式>  父类名n
{
    private:   数据成员/成员函数；
    protected: 数据成员/成员函数；
    public:    数据成员/成员函数
};

1. class关键字;
2. 子类名,最好C开头,再加名字;
3. 冒号;
	4. 派生方式,可省略,默认private;
	5. 父类名
6. 花括号;
7. 成员
8. 分号, 分号, 分号;
```

## `1.4 使用`

子类继承了父类的所有成员,但是不是任何成员都有访问权限;

权限与派生方式&父类成员访问修饰符相关;

# `2. 派生方式`

|                   | 父类成员public | 父类成员protected | 父类成员private |
| ----------------- | -------------- | ----------------- | --------------- |
| 派生方式public    | public         | protected         | 不可访问       |
| 派生方式protected | protected      | protected         | 不可访问       |
| 派生方式private   | private        | private           | 不可访问       |
中间的访问属性才是父类在子类中的访问属性.
# `3. 派生类内存`

其实计算机的一切都是数据,我们类的内存模型是怎样的,子类内存模型又是怎样的.

1. 一个正常的类内存模型与c语言中的结构体一样的;
2. 子类的内存模型: 基类内存模型 + 子类的自有内存模型;

# `4. 虚继承`

## `4.1 简述` 

当有如下类:

```
class A
{
	int m_a1 = 0;
	int m_a2 = 1;
};
class B1 : public A
{
	int m_b = 2;
};

class B2 : public A
{
	int m_b = 3;
};

class D : public B1, public B2
{
	int m_d = 4;
};


int main()
{
	int i = sizeof(A);
	i = sizeof(B1);
	i = sizeof(B2);
	i = sizeof(D);

	A a;
	B1 b1;
	B2 b2;
	D d;

	return 0;
}
```
`虚继承`

 指定一个基类,在继承体系结构中,将其成员数据实例共享给也从这个基类型直接或间接派生的其它类。

`声明`

```
class关键字  子类名  :  <派生方式>  父类名1, <派生方式>  父类名2, ... , <派生方式>  父类名n;

派生方式不仅可以有访问权限修饰符,还可以有虚继承关键字virtual.
Eg:
class A;
class B1:public virtual A;
class B2:public virtual A;
class D:public B1,public B2;
```

`技术状况`
虚拟继承在一般的应用中很少用到,所以也往往被忽视,这也主要是因为在C++中,多重继承是不推荐的,也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要;

`菱形继承`

 ![1525510917206](C:\Users\zzzer000\Documents\Typora\TanZhouEdu\Courseware\C++\7-0.png)

# `5. 作业`

俄罗斯方块:

我们都玩过俄罗斯方块,它的右边会有一个随机刷新形态;请用今天的知识做出来.

1. 必须使用派生.

2. 在控制台上打印出三种形态的方块.

   ```
   //************************************
   // Nam: PrintfChar
   // Dtl: 指定位置,指定颜色,指定字符串,打印
   // Prm: int x   
   // Prm: int y
   // Prm: WORD wClr
   // Prm: char * str
   // Ret: void
   //************************************
   void PrintfChar(int x, int y, WORD wClr, char * str)
   {
   	HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
   
   	CONSOLE_CURSOR_INFO cci{};
   	cci.dwSize = 1;
   	cci.bVisible = 0;
   	assert(SetConsoleCursorInfo(hOut, &cci));		//设置光标
   
   	COORD cd{};
   	cd.X = x*2;
   	cd.Y = y;
   	assert(SetConsoleCursorPosition(hOut, cd));		//设置光标位置 
   	assert(SetConsoleTextAttribute(hOut, wClr));	//设置文本属性
   
   	printf(str);									//打印
   }
   ```

3. 可以下移 (按下的时候,可以下移)

   ```
   #include <conio.h>
   #include <stdio.h>
   
   while (1)
   	{
   		if (_kbhit())		//_kbhit,百度去
   			printf("%c \n", _getch());
   	}
   ```

   