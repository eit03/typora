***
[TOC]
***

# `1. 虚函数`
## `1.1 引`
`有如下代码`
```
#include <stdio.h>


//俄罗斯方块矩阵信息
typedef struct _MATRIX_INFO
{
	int xPos{};				//俄罗斯方块矩阵x坐标
	int yPos{};				//俄罗斯方块矩阵y坐标
	int iArr[4][4]{};		//俄罗斯方块矩阵对应的数组, 0没有方块, 1有方块;
}MATRIX_INFO, *PMATRIX_INFO;	

//俄罗斯方块基类
class CMatrix		
{
private:
	MATRIX_INFO m_mi{};

public:
	void Output() { printf("这是一个矩阵方块 \n"); }
};

//俄罗斯方块I型
class CMatrixI : public CMatrix
{
public:
	void Output() { printf("这是一个I型矩阵方块 \n"); }
};

//俄罗斯方块L型
class CMatrixL : public CMatrix
{
public:
	void Output() { printf("这是一个L型矩阵方块 \n"); }
};

//俄罗斯方块O型
class CMatrixO : public CMatrix
{
public:
	void Output() { printf("这是一个O型矩阵方块 \n"); }
};

int main()
{
	// start
	CMatrix* pMatrix[3]{};

	// 1.创建对象
	//CMatrixI* pDerive = new CMatrix;		//不可以把父类的指针赋给子类指针变量;


	pMatrix[0] = new CMatrixI;		//可以把子类指针赋给父类指针变量;
	pMatrix[1] = new CMatrixL;		//可以把子类指针赋给父类指针变量;
	pMatrix[2] = new CMatrixO;		//可以把子类指针赋给次类指针变量;

	// 2.输出
	for (int i = 0; i < 3 ; i++)
	{
		if (pMatrix[i])
			pMatrix[i]->Output();	//调用的是谁?
	}
	//调用的是 CMatrix::Output(), 有没有方法调用对应的对象的成员函数?

	// end
	for (int i = 0; i < 3 ; i++)
	{
		if (pMatrix[i])
		{
			delete pMatrix[i];
			pMatrix[i] = 0;
		}
	}

	return 0;
}
```

1. 不可以把父类的指针赋给子类指针变量;
2. 可以把子类指针变量赋给父类指针变量;
3. 用父类指针只能调用父类函数,可以调用真实对象的成员函数么?如:
   如果真实对象是父类,就调用父类的Output(),
   如果真实对象是子类,就调用子类的Output();

## `1.2 简述`
> 那些被virtual关键字修饰的成员函数,就是虚函数.

> 虚函数的作用,用专业术语来解释就是实现多态性;
>
> 根据真实对象的不同,调用真实对象的函数;

## `1.3 声明`

在以前的成员函数前加virtual关键字;



如果子类与父类有同名函数,且父类中这个函数有virtual时,那么子类的这个函数不管是否有virtual,它都是虚函数;

## `1.4 定义`

与以前的成员函数没有区别;

## `1.5 使用`

- 与以前的成员函数的使用没有区别,但是调用的函数与调用方式是有区别的;

* 调用的函数: 调用的是真实对象的函数;
* 调用的方式: 以前的函数是直接调用函数体,多态方式是在虚表中取函数的地址;

## `1.6 override`

- 如果一个子类重载父类的函数,可在函数声明的花括号前加override关键字;
- 他没有实质的作用,只是一个标记;是否是虚函数是很重要的;
- 如果没有发生重载,override关键字会报错;

## `1.7 多态实现方式 (当听故事)`

1. 每个有虚函数(或自有,或继承)的类,它的内存模型,在最开始时会多4字节,就是虚函数表指针;
2. 虚函数表里保存着被本类重载的本类虚函数指针;
3. 当用指针方式调用一个虚函数时,会调用虚函数表里虚函数指针;

```
#include <stdio.h>


//俄罗斯方块矩阵信息
typedef struct _MATRIX_INFO
{
	int xPos{};				//俄罗斯方块矩阵x坐标
	int yPos{};				//俄罗斯方块矩阵y坐标
	int iArr[4][4]{};		//俄罗斯方块矩阵对应的数组, 0没有方块, 1有方块;
}MATRIX_INFO, *PMATRIX_INFO;	

//俄罗斯方块基类
class CMatrix
{
private:
	MATRIX_INFO m_mi{};

public:
	virtual void Output() { printf("这是一个矩阵方块 \n"); }
};

class CMatrixI : public CMatrix
{
public:
	void Output() override { printf("这是一个I型矩阵方块 \n"); }
};

class CMatrixL : public CMatrix
{
public:
	void Output() override { printf("这是一个L型矩阵方块 \n"); }
};

class CMatrixO : public CMatrix
{
public:
	void Output() override { printf("这是一个O型矩阵方块 \n"); }
};

int main()
{
	// start
	CMatrix* pMatrix[3]{};

	// 1.创建对象
	//CMatrixI* pDerive = new CMatrix;		//不可以把父类的指针变量赋给子类指针变量;

	pMatrix[0] = new CMatrixI;		//可以把子类指针变量赋给基类指针变量;
	pMatrix[1] = new CMatrixL;		//可以把子类指针变量赋给基类指针变量;
	pMatrix[2] = new CMatrixO;		//可以把子类指针变量赋给基类指针变量;
	
	// 2.输出
	for (int i = 0; i < 3 ; i++)
	{
		if (pMatrix[i])
			pMatrix[i]->Output();	//调用的是谁?
	}

	// end
	for (int i = 0; i < 3 ; i++)
	{
		if (pMatrix[i])
		{
			delete pMatrix[i];
			pMatrix[i] = 0;
		}
	}

	return 0;
}
```

# `2. 重写`

`重载`

- 同一类中
- 函数名相同
- 参数不同
- ==实质上是函数重载==

`覆盖 overrdie`
- ==覆盖是为了实现多态==
- 父类函数必须要有virtual
- 发生在父类与子类之中
- 函数名相同
- 参数表相同
- 覆盖了

`重写 overwrite`
- 不是virtual,也不是static
- 发生在父类与子类之中
- 函数名相同
- ==重写了,基类的同名函数被隐藏==
- 可以用作用域方式访问被隐藏的函数

# `3. 纯虚函数`

## `3.1 简述`
> 纯虚函数是一种特殊的虚函数,在许多情况下,在基类中不能对虚函数给出有意义的实现,而把它声明为纯虚函数,它的实现留给该基类的派生类去做.这就是纯虚函数的作用.

> 纯虚函数是为了方便多态.

## `3.2 声明`
> 本类中没有实现函数体,在子类中不是必须有实现.
```
virtual关键字  返回类型  函数名  ( 参数表 ) = 0 ;
```

## `3.3 定义`
> 没有函数体.

## `3.4 抽象类`
> 包含纯虚函数的类称为抽象类.由于抽象类包含了没有定义的纯虚函数,所以不能定义抽象类的对象.

> 抽象类有如果下特点:
> * 子类来实现接口类中没有实现的所有接口
> * 接口方法前面有virtual关键词修饰，并且等于0
> * 只能被继承,不能独自生成对象

# `4. 接口类`

## `4.1 简述`

> 接口类就是只提供接口不提供实现的类,就是接口类,接口类是抽象类的一个细分.

> 接口类有如下特点：
> - 子类来实现接口类中没有实现的所有接口
> - 接口方法前面有virtual关键词修饰，并且等于0
> - 只能被继承,不能独自生成对象
>
> 
>
> - 类中没有定义任何成员变量 
> - 类中所有成员函数都是公有且都是纯虚函数 
> - 接口是一种特殊的抽象类,所以抽象类具有只能被继承不能创建对象的特征它也具备

## `4.2 声明`
俄罗斯方块类CMatrix应该有一个Draw类画方块,但是这个不知道怎么画的,我们可以把它定义为一个接口,在具体形状的子类中实现.

## `4.3 定义`
> 本类中没有实现实现,在子类中必须有实现.

```
virtual关键字  返回类型  函数名  ( 参数表 ) = 0 ;
```

# `5. 虚函数表`
```
虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址。

C++中的虚函数的实现一般是通过虚函数表(C++规范并没有规定具体用哪种方法，但大部分的编译器厂商都选择此方法)。

注意的是，编译器会为每个有虚函数的类创建一个虚函数表，该虚函数表将被该类的所有对象共享。类的每个虚成员占据虚函数表中的一行。如果类中有N个虚函数，那么其虚函数表将有N*4字节的大小。

虚函数（Virtual Function）是通过一张虚函数表来实现的。简称为V-Table。在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。这样，在有虚函数的类的实例中分配了指向这个表的指针的内存，所以，当用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着可以通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。
```


# `6. 作业`

俄罗斯方块.

1. 我们都玩过俄罗斯方块,它的右边会有一个随机刷新形态;请用今天的知识做出来.必须使用: (必做)
   - 纯虚函数
   - 多态
2. 如果左边有一个俄罗斯方块,请实现俄罗斯方块的移动,可以上下左右. (必做)
3. 实现边界&碰撞的代码;可以有一个规则类,如果出了边界,则不移动; (必做)
4. 完美版的俄罗斯方块. (选做)